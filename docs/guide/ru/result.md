# Результат

Результатом валидации является объект, содержащий ошибки, возникшие во время
проверки.

## Валидация успешна?

Чтобы просто проверить статус валидации (валидны ли данные в целом),
используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->isValid();

```

Его можно сузить до определенного свойства:

```php
use Yiisoft\Validator\Result;

/** @var Result $result */
$result->isPropertyValid('name');
```

## Ошибки

В большинстве случаев недостаточно указать только статус
валидации. Существует несколько способов получить подробный список ошибок с
данными о них из результата. Разница между ними заключается в группировке,
фильтрации и представлении каждой ошибки. В зависимости от ситуации
выбирайте тот, который соответствует вашим потребностям.

### Плоский список сообщений об ошибках

Одним из самых простых случаев является получение плоского списка всех
сообщений об ошибках. Для этого используйте следующий API-вызов `Result`:


```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessages();
```

Пример вывода со свойствами `age` и `email`:

```php
[
    'Value must be no less than 21.',
    'This value is not a valid email address.',
    'A custom error message.',
];
```

Его легко показывать и перебирать, однако при большом количестве свойств и в
зависимости от сообщения, может быть проблематично понять, к какому свойству
относится ошибка.

#### Сообщения об ошибках, не привязанные к определенному свойству

Иногда сообщения об ошибках не связаны с конкретным свойством. Это может
случиться, например, во время валидации нескольких свойств, зависящих друг
от друга. В таком случае используйте следующий API-вызов `Result`:

```php
$result->getCommonErrorMessages();
```

Результат для примера выше:

```php
[
    'A custom error message.',
];
```

#### Фильтрация по определенному свойству

Список также может быть отфильтрован по конкретному свойству. Поддерживаются
свойства только верхнего уровня.

```php
$result->getPropertyErrorMessages('email');
```

Результат для примера выше:

```php
[
    'This value is not a valid email address.',
];
```

#### Фильтрация по определенному свойству

Этот список сообщений об ошибках можно отфильтровать по определенному пути к
свойству.

```php
$result->getPropertyErrorMessagesByPath(['person', 'first_name']);

```

### Сообщения об ошибках, сгруппированные по свойству

Для группировки сообщений об ошибках по свойству, используйте следующий
API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessagesIndexedByProperty();
```

Пример результата:

```php
[
    'name' => [
        'Value cannot be blank.',
        'This value must contain at least 4 characters.',
    ],
    'email' => ['This value is not a valid email address.'],
    // Сообщения об ошибках, не привязанные к конкретному свойству, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Обратите внимание, что результатом всегда является двумерный массив с
именами свойств в качестве ключей на первом уровне вложенности.
Это означает, что дальнейшее вложение свойств не поддерживается (но может
быть достигнуто с помощью
[`getErrorMessagesIndexedByPath()`](#сообщения-об-ошибках-сгруппированные-по-пути)).
Возвращаясь к предыдущему примеру, когда `name` и `email` принадлежат
свойству `user`, выходные данные будут такими:

```php
[
    'user' => [
        'Value cannot be blank.',
        'This value must contain at least 4 characters.',
        'This value is not a valid email address.'
    ],
    // Сообщения об ошибках, не привязанные к конкретному свойству, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Также имейте в виду, что имена свойств всегда являются строками, даже если
они используются с `Each`:

```php
$rule = new Each([new Number(min: 21)]),
```

Если входные данные содержат нестроковые ключи для свойств верхнего уровня,
например, `[21, 22, 23, 20]`, будет выброшено исключение
`InvalidArgumentException`.

Даже массив `['1' => 21, '2' => 22, '3' => 23, '4' => 20]` вызовет ошибку, поскольку PHP [приведет ключи к типу int].

Но если задан массив со строковыми ключами `['1a' => 21, '2b' => 22, '3c' => 23, '4d' => 20]`, вывод будет следующим:

```php
[
    '4d' => [
        0 => 'Value must be no less than 21.'
    ]
]
```

### Сообщения об ошибках, сгруппированные по пути

Вероятно, это самое продвинутое представление, предлагаемое встроенными
методами. Группировка осуществляется по пути - объединенной
последовательности свойств, показывающей расположение ошибочного значения в
структуре данных. Разделитель настраивается, точечная нотация используется
по умолчанию. Используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessagesIndexedByPath();
```

Пример результата:

```php
[
    'user.firstName' => ['Value cannot be blank.'],
    'user.lastName' => ['This value must contain at least 4 characters.'],
    'email' => ['This value is not a valid email address.'],
    // Сообщения об ошибках, не привязанные к конкретному свойству, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Путь также может содержать целочисленные элементы (например, при
использовании правила `Each`)

```php
[
    'charts.0.points.0.coordinates.y' => ['Value must be no greater than 10.'],
];
```

#### Разрешение конфликтов специальных символов в именах свойств

Если имя свойства в списке сообщений об ошибках содержит разделитель пути
(по умолчанию точка `.`) он автоматически экранируется обратной косой чертой
(`\`):

```php
[
    'country\.code' => ['Value cannot be blank.'],
],
```

В случае использования одного свойства в наборе правил любые дополнительные
изменения имен свойств в правилах конфигурации не требуются, поэтому они
должны оставаться такими, какие есть:

```php
use Yiisoft\Validator\Rule\In;
use Yiisoft\Validator\Rule\Required;

$rules = [
    'country.code' => [
        new Required();
        new In(['ru', 'en'], skipOnError: true),
    ],
];
```

Однако, при использовании правила `Nested` с несколькими свойствами в каждом
наборе правил, специальные символы необходимо экранировать с помощью
обратной косой черты (`\`) для того, чтобы пути к значениям были корректными
и можно было преобразовать их обратно из строки в индивидуальные
значения. Подробности смотрите в разделе [Использование ключей, содержащих
разделитель / сокращение].

Это можно использовать как альтернативу использования пользовательского
разделителя.

#### Фильтрация по определенному свойству

Список также может быть отфильтрован по конкретному свойству. Поддерживаются
атрибуты только верхнего уровня.

```php
use Yiisoft\Validator\Result;

/** @var Result $result */
$result->getPropertyErrorMessagesIndexedByPath('user');
```

Результат для примера выше:

```php
[
    'firstName' => ['Value cannot be blank.'],
    'lastName' => ['This value must contain at least 4 characters.'],
];
```

## Список объектов ошибок

Когда даже этих представлений недостаточно, доступ к исходному
немодифицированному списку объектов ошибок можно получить через этот метод:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrors();
```

Для каждой ошибки сохраняются следующие данные:

- - Сообщение. Любое простое сообщение типа `This value is wrong.` или
  шаблон с плейсхолдерами, заключенными в фигурные скобки, например: `Value
  must be no less than {min}.`. Фактическое форматирование выполняется в
  `Validator` в зависимости от настроек.
- Параметры шаблона для подстановки при форматировании, например: `['min' =>
  7]`.
- Путь к значению в проверяемой структуре данных, например: `['user',
  'name', 'firstName']`.

### Пример приложения

Чем это может быть полезно? Например, чтобы построить вложенное дерево
сообщений об ошибках, сгруппированное по именам свойств:

```php
[
    'user' => [
        'name' => [
            'firstName' => ['Value cannot be blank.'],
            'lastName' => ['This value must contain at least 4 characters.'],
        ],
    ],
    'email' => ['This value is not a valid email address.'],    
];
```

Это намеренно не предусмотрено из коробки из-за сложности итерации. Однако
может быть полезно, например, для дампа JSON или сохранения в лог.

Отладка исходных объектов ошибок также становится более удобной.

### Фильтрация по определенному свойству

Список также может быть отфильтрован по конкретному свойству. Поддерживаются
свойства только верхнего уровня.

```php
use Yiisoft\Validator\Result;

/** @var Result $result */
$result->getPropertyErrors('email');
```

[Использование ключей, содержащих разделитель / сокращение]: built-in-rules-nested.md#using-keys-containing-separator--shortcut
[приведет ключи к типу int]: https://www.php.net/manual/ru/language.types.array.php
