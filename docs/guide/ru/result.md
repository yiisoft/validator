# Результат

Результатом валидации является объект, содержащий ошибки, возникшие во время проверки.

## Валидация успешна?

Чтобы просто проверить статус валидации (валидны ли данные в целом), используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->isValid();
```

Его можно сузить до определенного атрибута:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->isAttributeValid('name');
```

## Ошибки

В большинстве случаев недостаточно указать только статус валидации.
Существует несколько способов получить подробный список ошибок с данными о них из результата.
Разница между ними заключается в группировке, фильтрации и представлении каждой ошибки.
В зависимости от ситуации выбирайте тот, который соответствует вашим потребностям.

### Плоский список сообщений об ошибках

Одним из самых простых случаев является получение плоского списка всех сообщений об ошибках.
Для этого используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessages();
```

Пример вывода с атрибутами `age` и `email`:

```php
[
    'Значение должно быть не меньше 21.',
    'Значение не является валидным email адресом.',
    'Пользовательское сообщение об ошибке.',
];
```

Его легко показывать и перебирать, однако при большом количестве атрибутов и в зависимости от сообщения, может быть проблематично понять, к какому атрибуту относится ошибка.

#### Сообщения об ошибках, не привязанные к определенному атрибуту

Иногда сообщения об ошибках не связаны с конкретным атрибутом.
Это может случиться, например, во время валидации нескольких атрибутов, зависящих друг от друга.
В таком случае используйте следующий API-вызов `Result`:

```php
$result->getCommonErrorMessages();
```

Результат для примера выше:

```php
[
    'Пользовательское сообщение об ошибке.',
];
```

#### Фильтрация по определенному атрибуту

Список также может быть отфильтрован по конкретному атрибуту. Поддерживаются атрибуты только верхнего уровня.

```php
$result->getAttributeErrorMessages('email');
```

Результат для примера выше:

```php
[
    'This value is not a valid email address.',
];
```

### Сообщения об ошибках, сгруппированные по атрибуту

Для группировки сообщений об ошибках по атрибуту, используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessagesIndexedByAttribute();
```

Пример результата:

```php
[
    'name' => [
        'Value cannot be blank.',
        'This value must contain at least 4 characters.',
    ],
    'email' => ['This value is not a valid email address.'],
    // Сообщения об ошибках, не привязанные к конкретному атрибуту, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Обратите внимание, что результатом всегда является двумерный массив с именами атрибутов в качестве ключей на первом уровне вложенности.
Это означает, что дальнейшее вложение атрибутов не поддерживается (но может быть достигнуто с помощью [`getErrorMessagesIndexedByPath()`](#сообщения-об-ошибках-сгруппированные-по-пути)).
Возвращаясь к предыдущему примеру, когда `name` и `email` принадлежат атрибуту `user`, выходные данные будут такими:

```php
[
    'user' => [
        'Value cannot be blank.',
        'This value must contain at least 4 characters.',
        'This value is not a valid email address.'
    ],
    // Сообщения об ошибках, не привязанные к конкретному атрибуту, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Также имейте в виду, что имена атрибутов всегда являются строками, даже если они используются с `Each`:

```php
$rule = new Each([new Number(min: 21)]),
```
Передавая `[21, 22, 23, 20]` input, результат будет следующим: 

```php
[
    '1' => ['Value must be no less than 21.'],
    '2' => ['Value must be no less than 21.'],
],
```

### Сообщения об ошибках, сгруппированные по пути

Вероятно, это самое продвинутое представление, предлагаемое встроенными методами.
Группировка осуществляется по пути - объединенной последовательности атрибутов, показывающей расположение ошибочного значения в структуре данных.
Разделитель настраивается, точечная нотация используется по умолчанию. Используйте следующий API-вызов `Result`:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrorMessagesIndexedByPath();
```

Пример результата:

```php
[
    'user.firstName' => ['Value cannot be blank.'],
    'user.lastName' => ['This value must contain at least 4 characters.'],
    'email' => ['This value is not a valid email address.'],
    // Сообщения об ошибках, не привязанные к конкретному атрибуту, группируются в ключе со значением пустая строка.
    '' => ['A custom error message.'],
];
```

Путь также может содержать целочисленные элементы (например, при использовании правила `Each`)

```php
[
    'charts.0.points.0.coordinates.y' => ['Value must be no greater than 10.'],
];
```

#### Разрешение конфликтов специальных символов в именах атрибутов

Если имя атрибута в списке сообщений об ошибках содержит разделитель пути (по умолчанию точка `.`) он автоматически экранируется обратной косой чертой (`\`):

```php
[
    'country\.code' => ['Value cannot be blank.'],
],
```

В случае использования одного атрибута в наборе правил любые дополнительные изменения имен атрибутов в правилах конфигурации не требуются, поэтому они должны оставаться такими, какие есть:

```php
use Yiisoft\Validator\Rule\In;
use Yiisoft\Validator\Rule\Required;

$rules = [
    'country.code' => [
        new Required();
        new In(['ru', 'en'], skipOnError: true),
    ],
];
```

Однако, при использовании правила `Nested` с несколькими атрибутами в каждом наборе правил, специальные символы необходимо экранировать с помощью обратной косой черты (`\`) для того, чтобы пути к значениям были корректными и можно было преобразовать их обратно из строки в индивидуальные значения.
Подробности смотрите в разделе [Использование ключей, содержащих разделитель / сокращение].

Это можно использовать как альтернативу использования пользовательского разделителя.

#### Фильтрация по определенному атрибуту

Список также может быть отфильтрован по конкретному атрибуту. Поддерживаются атрибуты только верхнего уровня.

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getAttributeErrorMessagesIndexedByPath('user');
```

Результат для примера выше:

```php
[
    'firstName' => ['Value cannot be blank.'],
    'lastName' => ['This value must contain at least 4 characters.'],
];
```

## Список объектов ошибок

Когда даже этих представлений недостаточно, доступ к исходному немодифицированному списку объектов ошибок можно получить через этот метод:

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getErrors();
```

Для каждой ошибки сохраняются следующие данные:

- Сообщение. Любое простое сообщение типа `This value is wrong.` или шаблон с плейсхолдерами, заключенными в фигурные скобки, например:  `Value must be no less than {min}.`. Фактическое форматирование выполняется в `Validator` в зависимости от настроек.
- Параметры шаблона для подстановки при форматировании, например: `['min' => 7]`.
- Путь к значению в проверяемой структуре данных, например: `['user', 'name', 'firstName']`.

### Пример приложения

Чем это может быть полезно? Например, чтобы построить вложенное дерево сообщений об ошибках, сгруппированное по именам атрибутов:

```php
[
    'user' => [
        'name' => [
            'firstName' => ['Value cannot be blank.'],
            'lastName' => ['This value must contain at least 4 characters.'],
        ],
    ],
    'email' => ['This value is not a valid email address.'],    
];
```

Это намеренно не предусмотрено из коробки из-за сложности итерации.
Однако может быть полезно, например, для дампа JSON или сохранения в лог.

Отладка исходных объектов ошибок также становится более удобной.

### Фильтрация по определенному атрибуту

Список также может быть отфильтрован по конкретному атрибуту. Поддерживаются атрибуты только верхнего уровня.

```php
use Yiisoft\Validator\Result;

/** @var Result */
$result->getAttributeErrors('email');
```

[Использование ключей, содержащих разделитель / сокращение]: built-in-rules-nested.md#using-keys-containing-separator--shortcut
